{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Felis documentation - Alice &amp; Bob","text":"<p>Welcome to Felis, Alice &amp; Bob\u2019s toolkit to let you experiment with cat qubits! \ud83d\ude3a</p> <p>With Felis, you can run quantum circuits:</p> <ul> <li> <p>On the latest Boson 4 quantum chip by Alice &amp; Bob (Felis Cloud subscription required)</p> </li> <li> <p>On cat qubits emulators (locally or through Felis Cloud)</p> </li> </ul> <p>Get started now by installing the Qiskit provider.</p> <p>Any questions or feedback? Read our FAQ or contact us.</p>"},{"location":"contact_us/","title":"Contact us","text":"<p>Need help? Have feedback?</p> <ul> <li>In most cases, you'll get the best support on The Cat Tree, our Slack community</li> <li>For sales inquiries or issues requiring more confidentiality, please use https://alice-bob.com/cloud-contact</li> </ul> <p>We\u2019ll be happy to know what you think, and we also take positive feedback! \ud83d\ude42</p> <p>We usually respond to inquiries within one working day (based on the French calendar).</p>"},{"location":"backends/about_backends/","title":"Backends","text":""},{"location":"backends/about_backends/#about-backends","title":"About backends","text":"<p>Our backends are all named following the pattern <code>[EMU|QPU]:xxQ:NAME</code>, where:</p> <ul> <li><code>EMU</code> or <code>QPU</code> indicates whether this backend is an emulator (<code>EMU</code>) or a real quantum chip (<code>QPU</code>)</li> <li><code>xxQ</code> indicates the maximum number of qubits of circuits supported by the backend (for example <code>1Q</code>, <code>7Q</code>, <code>40Q</code>\u2026)</li> <li><code>NAME</code> describes the chip being used or emulated</li> </ul> <p>Note: Although some emulators support circuits with up to 40 qubits, using more than 10 or 15 qubits may result in execution being slow or failing altogether. The exact limit depends on your computer's memory and computing power.</p>"},{"location":"backends/about_backends/#list-of-available-backends","title":"List of available backends","text":"Backend Available in remote provider Available in local provider QPU:1Q:BOSON_4A \u2705 \u274c QPU:1Q:BOSON_4B \u2705 \u274c QPU:1Q:BOSON_4C \u2705 \u274c EMU:1Q:LESCANNE_2020 \u2705 \u2705 EMU:6Q:PHYSICAL_CATS \u2705 \u2705 EMU:40Q:PHYSICAL_CATS \u2705 \u2705 EMU:15Q:LOGICAL_EARLY \u2705 \u2705 EMU:40Q:LOGICAL_TARGET \u2705 \u2705 EMU:40Q:LOGICAL_NOISELESS \u2705 \u2705 <p>Supported instructions depend on each backend.</p> <p>Click a backends' name to see the instructions it supports, or check the supported_instructions page.</p>"},{"location":"backends/about_backends/#how-to-check-available-backends","title":"How to check available backends","text":"<p>You may list the backends supported by your version of the provider.</p> <p>Here is an example with the local provider:</p> <pre><code>from qiskit_alice_bob_provider import AliceBobLocalProvider\n\nlocal = AliceBobLocalProvider\n\nprint(local.backends())\n</code></pre> <p>Note that some backends are only supported by the remote or the local provider (see the table above to know which).</p> <p>If one of the backends documented here does not appear in any of your providers, you may need to update your provider with:</p> <pre><code>pip install --update qiskit-alice-bob-provider\n</code></pre>"},{"location":"backends/logical_physical/","title":"Logical mode and physical mode","text":"<p>Since the purpose of cat qubits is to create logical qubits with a very low error rate, a processor based on cat qubits can run in two modes: physical and logical.</p>"},{"location":"backends/logical_physical/#physical-mode","title":"Physical mode","text":"<p>In the physical mode, you\u2019re working directly with cat qubits: one qubit in your quantum circuit corresponds to one physical cat qubit on the chip.</p> <p>This enables you to leverage the biased noise of cat qubits for your error correction experiments, but only lets you use a limited set of gates (see Supported instructions for more details).</p> <p>Indeed, when using cat qubits in physical mode, it only makes sense to use so-called \u201cbias-preserving\u201d gates, which do no leak information from the noisy phase channel to the clean bit channel.</p> <p>This means that gates such as the Hadamard gate are forbidden, since they do contaminate the bit channel with phase errors.</p> <p>In physical mode, you\u2019ll also need to take the chip\u2019s connectivity into account, since cat qubits are usually only connected with their nearest neighbor. Although Qiskit\u2019s transpiler can do this job for you, transpilation may push the qubit number beyond the limits of what the emulator or the chip can do.</p> <p>You\u2019ll use the physical mode if you want to study the properties of cat qubits, implement error correction or create your own logical qubit.</p>"},{"location":"backends/logical_physical/#logical-mode","title":"Logical mode","text":"<p>In the logical mode, you\u2019re working with error-corrected logical qubits: one qubit in your quantum circuit corresponds to a group of several physical qubits on the chip.</p> <p>This mode is more abstract that the physical mode, since all the error correction operations leveraging several physical qubits are hidden in the compilation step.</p> <p>But the logical mode is the perfect choice to run quantum algorithms: you can execute any quantum gate, you get low error rates and all-to-all connectivity.</p> <p>Also, the logical mode does not feature a noise bias as strong as in physical mode. The exact bias depends on the tuning of the chip (distance of the code, number of photons), but a good tuning can make bit-flip and phase-flip errors equally (un)likely.</p> <p>The logical mode is only possible with chips featuring enough physical cat qubits to run an effective error correction code. We estimate this minimal number to be somewhere between 5 (for a first demonstration of a single logical qubit) and 40 (for very high fidelities or multi-qubit logical operations).</p>"},{"location":"backends/set_parameters/","title":"Set backend parameters","text":"<p>Depending on the backend, some settings affecting the backend's noise characteristics can be configured.</p>"},{"location":"backends/set_parameters/#available-parameters","title":"Available parameters","text":""},{"location":"backends/set_parameters/#summary","title":"Summary","text":"Model average_nb_photons kappa_1 kappa_2 distance Availability QPU:1Q:BOSON_4A \u2705 \u274c \u274c \u274c Remote only QPU:1Q:BOSON_4B \u2705 \u274c \u274c \u274c Remote only QPU:1Q:BOSON_4C \u2705 \u274c \u274c \u274c Remote only EMU:1Q:LESCANNE_2020 \u2705 \u274c \u274c \u274c Remote &amp; Local EMU:6Q:PHYSICAL_CATS \u2705 \u2705 \u2705 \u274c Remote &amp; Local EMU:40Q:PHYSICAL_CATS \u2705 \u2705 \u2705 \u274c Remote &amp; Local EMU:15Q:LOGICAL_EARLY \u2705 \u2705 \u2705 \u2705 Remote &amp; Local EMU:40Q:LOGICAL_TARGET \u2705 \u2705 \u2705 \u2705 Remote &amp; Local EMU:40Q:LOGICAL_NOISELESS \u274c \u274c \u274c \u274c Remote &amp; Local"},{"location":"backends/set_parameters/#average-number-of-photons","title":"Average number of photons","text":"<ul> <li><code>average_nb_photons</code> is the number photons trapped in the qubit\u2019s cavity.</li> <li>Increasing it will exponentially decrease the number of bit-flips, at the cost of a linear increase of the number of phase-flips.</li> <li>This parameter is available in all backends.</li> </ul>"},{"location":"backends/set_parameters/#kappa_1-and-kappa_2","title":"\\(\\kappa_1\\) and \\(\\kappa_2\\)","text":""},{"location":"backends/set_parameters/#kappa_1","title":"\\(\\kappa_1\\)","text":"<ul> <li><code>kappa_1</code> is the one-photon loss rate, expressed in Hz.</li> <li>Qubit quality decreases as <code>kappa_1</code> increases, since one-photon losses causes phase-flips.</li> <li>Boson 4 chips feature <code>kappa_1 = 3.14*19_900</code>.</li> <li>This parameter is not available on a real chip and on digital twin emulators.</li> </ul>"},{"location":"backends/set_parameters/#kappa_2","title":"\\(\\kappa_2\\)","text":"<ul> <li><code>kappa_2</code> is the two photon-loss rate, expressed in Hz.</li> <li>Qubit quality increases as <code>kappa_2</code> increases, since the exchange of pairs of photons is used to stabilize the qubit.</li> <li>Boson 4 chips feature <code>kappa_2 = 3.14*250_000</code>.</li> <li>This parameter is not available on a real chip and on digital twin emulators.</li> </ul>"},{"location":"backends/set_parameters/#kappa_1kappa_2","title":"\\(\\kappa_1/\\kappa_2\\)","text":"<ul> <li>The \\(\\kappa_1/\\kappa_2\\) ratio is a good proxy for the quality of the physical chip.</li> <li>The lower this ratio, the higher the quality of the chip.</li> <li>Current Alice &amp; Bob chips feature \\(\\kappa_1/\\kappa_2 &lt; 10^{-2}\\)</li> <li>Getting error correction to work reliably requires \\(\\kappa_1/\\kappa_2 &lt; 10^{-3}\\)</li> <li>Creating 100 logical qubits at a \\(10^{-8}\\) error rate with 1500 qubits requires \\(\\kappa_1/\\kappa_2 &lt; 10^{-4}\\), as shown in this article</li> <li>Running Shor's algorithm on a 2048-bit number requires \\(\\kappa_1/\\kappa_2 &lt; 10^{-5}\\), as shown in this article</li> </ul>"},{"location":"backends/set_parameters/#repetition-code-distance","title":"Repetition code distance","text":"<ul> <li><code>distance</code> is the distance of the error correction code, i.e. the number of physical qubits used to create a logical qubits.</li> <li>Phase-flips are exponentially removed as the distance of the code is increased, but bit-flips increase linearly.</li> <li>This parameter is only available for logical backends.</li> </ul>"},{"location":"backends/set_parameters/#set-parameters","title":"Set parameters","text":"<p>Parameters may be set while initializing a backend:</p> <pre><code>from qiskit_alice_bob_provider import AliceBobLocalProvider\nfrom qiskit import QuantumCircuit\n\nprovider = AliceBobLocalProvider()\n\nbackend = local.get_backend('EMU:1Q:LESCANNE_2020', average_nb_photons=3)\nbackend = local.get_backend('EMU:6Q:PHYSICAL_CATS', average_nb_photons=5)\nbackend = local.get_backend('EMU:40Q:PHYSICAL_CATS', kappa_2=500_000)\nbackend = local.get_backend('EMU:15Q:LOGICAL_EARLY', distance=13)\n\ncircuit = QuantumCircuit(...)\n# ...\n\nbackend.run(circuit, shots=3000)\n</code></pre> <p>Or when executing a circuit:</p> <pre><code>from qiskit_alice_bob_provider import AliceBobRemoteProvider\nfrom qiskit import QuantumCircuit\n\n# Replace the placeholder with your actual API key in the line below\nremote = AliceBobRemoteProvider(api_key='YOUR_API_KEY')\n\nbackend = remote.get_backend('EMU:1Q:LESCANNE_2020')\n\ncircuit = QuantumCircuit(...)\n# ...\n\nbackend.run(circuit, shots=3000, average_nb_photons=3)\n</code></pre>"},{"location":"backends/backends_list/40_physical_cats/","title":"40 physical cats","text":"<p>Backend name : <code>EMU:40Q:PHYSICAL_CATS</code></p> <p>Backend type : Emulator, physical</p>"},{"location":"backends/backends_list/40_physical_cats/#about-this-backend","title":"About this backend","text":"<p><code>EMU:40Q:PHYSICAL_CATS</code> reproduces the behavior of a chip featuring 40 cat qubits connected in a grid pattern.</p> <p>It only supports bias-preserving gates (see Supported instructions).</p> <p>It can be used to implement a long error correction code, or logical operations between several logical qubits using a shorter code.</p> <p>This backend is configured to have the same properties as the qubits used in the paper\u00a0High-performance repetition cat code using fast noisy operations\u00a0[Le R\u00e9gent et al., 2022].</p> <p>\u26a0\ufe0f Although this backend makes it possible to choose from 40 different qubits, using it to run circuits using more than ~10-15 qubits will likely be slow or fail altogether. The exact limit depends on the capabilities of your machine.</p>"},{"location":"backends/backends_list/40_physical_cats/#supported-backend-parameters","title":"Supported backend parameters","text":"<ul> <li><code>average_nb_photons</code><ul> <li>Supported values: 4 and above</li> </ul> </li> <li><code>kappa_1</code><ul> <li>Supported values: 10 and above</li> </ul> </li> <li><code>kappa_2</code><ul> <li>Supported values: 100 and above</li> </ul> </li> </ul> <p>\ud83d\udca1 The <code>kappa_1 / kappa_2</code> ratio must be between 1e-7 and 1e-1</p> <p>Read more about backend parameters here</p>"},{"location":"backends/backends_list/40_physical_cats/#supported-gates","title":"Supported gates","text":"<ul> <li><code>delay</code></li> <li><code>initialize(value, 0)</code><ul> <li><code>value</code> can only be one of the following: <code>0</code>, <code>1</code>, <code>+</code> or <code>-</code></li> </ul> </li> <li><code>z(0)</code></li> <li><code>x(0)</code></li> <li><code>rz(0)</code></li> <li><code>cx(control_index, target_index)</code></li> <li><code>measure(0, clbit_index)</code></li> <li><code>measure_x(0, clbit_index)</code></li> </ul> <p>Read more about supported gates here.</p>"},{"location":"backends/backends_list/40_physical_cats/#supported-providers","title":"Supported providers","text":"<ul> <li>\u2705 <code>AliceBobLocalProvider</code></li> <li>\u2705 <code>AliceBobRemoteProvider</code></li> </ul>"},{"location":"backends/backends_list/40_physical_cats/#connectivity","title":"Connectivity","text":""},{"location":"backends/backends_list/40_physical_cats/#expected-performance","title":"Expected performance","text":"<p>This backend features an error model based on theoretical papers. It is not meant to accurately reproduce a specific current or future Alice &amp; Bob chip.</p> <p>The formulas and references we used are documented in the source code at https://github.com/Alice-Bob-SW/qiskit-alice-bob-provider/blob/main/qiskit_alice_bob_provider/processor/physical_cat.py</p>"},{"location":"backends/backends_list/40_physical_cats/#availability-schedule","title":"Availability schedule","text":"<p>As an emulator, this backend is expected to be available 24/7.</p> <p>Live status for backends is available at https://api-gcp.alice-bob.com/console/status.</p>"},{"location":"backends/backends_list/6_physical_cats/","title":"6 physical cats","text":"<p>Backend name : <code>EMU:6Q:PHYSICAL_CATS</code></p> <p>Backend type : Emulator, physical</p>"},{"location":"backends/backends_list/6_physical_cats/#about-this-backend","title":"About this backend","text":"<p><code>EMU:6Q:PHYSICAL_CATS</code> reproduces the behavior of a chip featuring 6 cat qubits, with a circular neighbor connectivity (each qubit has two neighbors).</p> <p>It only supports bias-preserving gates (see Supported instructions).</p> <p>It can be used to implement the smallest error correction code.</p> <p>This backend is configured to have the same properties as the qubits used in the paper\u00a0High-performance repetition cat code using fast noisy operations\u00a0[Le R\u00e9gent et al., 2022].</p>"},{"location":"backends/backends_list/6_physical_cats/#supported-backend-parameters","title":"Supported backend parameters","text":"<ul> <li><code>average_nb_photons</code><ul> <li>Supported values: 4 and above</li> </ul> </li> <li><code>kappa_1</code><ul> <li>Supported values: 10 and above</li> </ul> </li> <li><code>kappa_2</code><ul> <li>Supported values: 100 and above</li> </ul> </li> </ul> <p>\ud83d\udca1 The <code>kappa_1 / kappa_2</code> ratio must be between 1e-7 and 1e-1</p> <p>Read more about backend parameters here</p>"},{"location":"backends/backends_list/6_physical_cats/#supported-gates","title":"Supported gates","text":"<ul> <li><code>delay</code></li> <li><code>initialize(value, 0)</code><ul> <li><code>value</code> can only be one of the following: <code>0</code>, <code>1</code>, <code>+</code> or <code>-</code></li> </ul> </li> <li><code>z(0)</code></li> <li><code>x(0)</code></li> <li><code>rz(0)</code></li> <li><code>cx(control_index, target_index)</code></li> <li><code>measure(0, clbit_index)</code></li> <li><code>measure_x(0, clbit_index)</code></li> </ul> <p>Read more about supported gates here.</p>"},{"location":"backends/backends_list/6_physical_cats/#supported-providers","title":"Supported providers","text":"<ul> <li>\u2705 <code>AliceBobLocalProvider</code></li> <li>\u2705 <code>AliceBobRemoteProvider</code></li> </ul>"},{"location":"backends/backends_list/6_physical_cats/#connectivity","title":"Connectivity","text":""},{"location":"backends/backends_list/6_physical_cats/#expected-performance","title":"Expected performance","text":"<p>This backend features an error model based on theoretical papers. It is not meant to accurately reproduce a specific current or future Alice &amp; Bob chip.</p> <p>The formulas and references we used are documented in the source code at https://github.com/Alice-Bob-SW/qiskit-alice-bob-provider/blob/main/qiskit_alice_bob_provider/processor/physical_cat.py</p>"},{"location":"backends/backends_list/6_physical_cats/#availability-schedule","title":"Availability schedule","text":"<p>As an emulator, this backend is expected to be available 24/7.</p> <p>Live status for backends is available at https://api-gcp.alice-bob.com/console/status.</p>"},{"location":"backends/backends_list/boson_4/","title":"QPU:1Q:BOSON_4A (or 4B, or 4C)","text":"<p>Backend name : <code>EMU:1Q:BOSON_4A</code> (or 4B, or 4C)</p> <p>Backend type : Hardware, physical</p>"},{"location":"backends/backends_list/boson_4/#about-this-backend","title":"About this backend","text":"<p>The <code>QPU:1Q:BOSON_4x</code> backends are real quantum chips using a Boson 4 design, located in Alice &amp; Bob\u2019s offices</p> <p>Three chips are currently available in rotation (usually, only one at a time):</p> <ul> <li><code>QPU:1Q:BOSON_4A</code></li> <li><code>QPU:1Q:BOSON_4B</code></li> <li><code>QPU:1Q:BOSON_4C</code></li> </ul> <p>You may check which chip is currently online on your status page.</p> <p>Boson 4 chips feature two independant cat qubits of identical design, one of which is exposed through this backend.</p> <p><code>QPU:1Q:BOSON_4x</code> backends are only available through the remote provider, with a Felis Cloud subscription.</p> <p>\ud83d\udca1 Note: While all Boson 4 chips feature roughly identical performance, we still expose them as different backends so you can know exactly which chip you used in a given experiment.</p> <p></p>"},{"location":"backends/backends_list/boson_4/#supported-backend-parameters","title":"Supported backend parameters","text":"<ul> <li><code>average_nb_photons</code><ul> <li>Supported values: 4 to 16</li> </ul> </li> </ul> <p>Read more about backend parameters here</p>"},{"location":"backends/backends_list/boson_4/#supported-gates","title":"Supported gates","text":"<ul> <li><code>delay</code><ul> <li>\ud83d\udca1 Note: Be careful when using long delays. Circuits taking longer than 15 minutes to execute (circuit duration * number of shots) will be refused by our API, so that processing time is shared fairly between all users.</li> </ul> </li> <li><code>initialize(value, 0)</code><ul> <li><code>value</code> can only be one of the following: <code>0</code>, <code>1</code>, <code>+</code> or <code>-</code></li> </ul> </li> <li><code>z(0)</code></li> <li><code>x(0)</code><ul> <li>\ud83d\udca1 Note: The <code>x</code> gate is implemented virtually in this backend, at the transpilation step<ul> <li>For example, <code>initialize('0', 0)</code> + <code>x</code> is transpiled into <code>initialize('1', 0)</code></li> </ul> </li> </ul> </li> <li><code>measure(0, clbit_index)</code></li> <li><code>measure_x(0, clbit_index)</code></li> </ul> <p>Read more about supported gates here.</p>"},{"location":"backends/backends_list/boson_4/#supported-providers","title":"Supported providers","text":"<ul> <li>\u274c ~~<code>AliceBobLocalProvider</code>~~</li> <li>\u2705 <code>AliceBobRemoteProvider</code></li> </ul>"},{"location":"backends/backends_list/boson_4/#connectivity","title":"Connectivity","text":"<p>N/A - This backend features a single qubit.</p>"},{"location":"backends/backends_list/boson_4/#expected-performance","title":"Expected performance","text":"<p>See Boson 4 chips</p>"},{"location":"backends/backends_list/boson_4/#availability-schedule","title":"Availability schedule","text":"<p>See Hardware availability schedule</p>"},{"location":"backends/backends_list/lescanne_2020/","title":"Lescanne 2020","text":"<p>Backend name : <code>EMU:1Q:LESCANNE_2020</code></p> <p>Backend type : Emulator, physical</p>"},{"location":"backends/backends_list/lescanne_2020/#about-this-backend","title":"About this backend","text":"<p><code>EMU:1Q:LESCANNE_2020</code> is a numerical model emulating the processor used in the seminal paper by Rapha\u00ebl Lescanne in 2020, featuring a single cat qubit.</p> <p>This numerical model is configured to act as a digital twin of the chip used in this paper, using the following parameters:</p> <ul> <li>Readout assignment matrix for Mz and Mx: P(1|0)=0.02, P(0|1)=0.06</li> <li>Perfect preparation for Px and Pz</li> <li>Pauli error probabilities interpolated for the \u201cdelay/idle\u201d instruction from the T_bf and Gamma_pf plots in the paper</li> </ul> <p>Please note that this design dates back to 2020 and does not represent the current performance of Alice &amp; Bob's cat qubits. Better designs such as the ones documented here have been introduced and will soon be available through Felis.</p>"},{"location":"backends/backends_list/lescanne_2020/#supported-backend-parameters","title":"Supported backend parameters","text":"<ul> <li><code>average_nb_photons</code><ul> <li>Supported values: 1 to 7</li> </ul> </li> </ul> <p>Read more about backend parameters here</p>"},{"location":"backends/backends_list/lescanne_2020/#supported-gates","title":"Supported gates","text":"<ul> <li><code>delay</code></li> <li><code>initialize(value, 0)</code><ul> <li><code>value</code> can only be one of the following: <code>0</code>, <code>1</code>, <code>+</code> or <code>-</code></li> </ul> </li> <li><code>z(0)</code></li> <li><code>rz(0)</code></li> <li><code>measure(0, clbit_index)</code></li> <li><code>measure_x(0, clbit_index)</code></li> </ul> <p>Read more about supported gates here.</p>"},{"location":"backends/backends_list/lescanne_2020/#supported-providers","title":"Supported providers","text":"<ul> <li>\u2705 <code>AliceBobLocalProvider</code></li> <li>\u2705 <code>AliceBobRemoteProvider</code></li> </ul>"},{"location":"backends/backends_list/lescanne_2020/#connectivity","title":"Connectivity","text":"<p>N/A - This backend features a single qubit.</p>"},{"location":"backends/backends_list/lescanne_2020/#expected-performance","title":"Expected performance","text":"<p>A sample notebook showing this backend's bit-flip and phase-flip scaling is available at https://github.com/Alice-Bob-SW/felis/blob/main/samples/1_hardware_experiments/1%20-%20Bit-flip%20and%20phase-flip%20scaling%20on%20a%20physical%20qubit.ipynb.</p>"},{"location":"backends/backends_list/lescanne_2020/#availability-schedule","title":"Availability schedule","text":"<p>As an emulator, this backend is expected to be available 24/7.</p> <p>Live status for backends is available at https://api-gcp.alice-bob.com/console/status.</p>"},{"location":"backends/backends_list/logical_early/","title":"15 logical qubits","text":"<p>Backend name : <code>EMU:15Q:LOGICAL_EARLY</code></p> <p>Backend type : Emulator, logical</p>"},{"location":"backends/backends_list/logical_early/#about-this-backend","title":"About this backend","text":"<p><code>EMU:15Q:LOGICAL_EARLY</code> reproduces what might be the behavior of one of the first useful logical chips, featuring 15 logical qubits with conservative hypotheses on qubit quality.</p> <p>In this backend, information is physically stored in 13 \"data\" cat qubits (carrying the information of the logical qubit) and 12 \"ancilla\" cat qubits (used to perform error detection operations).</p> <p>Physical qubits are abstracted here - errors are emulated using an analytical formula rather than by emulating the individual behavior of each physical qubit.</p> <p>Logical error rates are between \\(10^{-3}\\) and \\(10^{-4}\\), but they can be made better (or worse) by tuning the <code>average_nb_photons</code>, <code>kappa_1</code>, <code>kappa_2</code>, and <code>distance</code> parameters - see Chip settings for more details.</p>"},{"location":"backends/backends_list/logical_early/#supported-backend-parameters","title":"Supported backend parameters","text":"<ul> <li><code>average_nb_photons</code><ul> <li>Default value: 7</li> <li>Supported values: 4 and above</li> </ul> </li> <li><code>distance</code><ul> <li>Default value: 13</li> <li>Supported values: 3 and above, odd integers only</li> </ul> </li> <li><code>kappa_1</code><ul> <li>Default value: 100</li> <li>Supported values: 10 and above</li> </ul> </li> <li><code>kappa_2</code><ul> <li>Default value: 100 000</li> <li>Supported values: 100 and above</li> </ul> </li> </ul> <p>\ud83d\udca1 The <code>kappa_1 / kappa_2</code> ratio must be between 1e-7 and 1e-1</p> <p>Read more about backend parameters here</p>"},{"location":"backends/backends_list/logical_early/#supported-gates","title":"Supported gates","text":"<ul> <li><code>initialize</code> (custom Felis gate)</li> <li><code>measure_x</code> (custom Felis gate)</li> <li><code>delay</code> (native Qiskit gate)</li> <li><code>x</code> (native Qiskit gate)</li> <li><code>z</code> (native Qiskit gate)</li> <li><code>measure</code> (native Qiskit gate)</li> <li><code>t</code> (native Qiskit gate)</li> <li><code>tdg</code> (native Qiskit gate)</li> <li><code>h</code> (native Qiskit gate)</li> <li><code>s</code> (native Qiskit gate)</li> <li><code>sdg</code> (native Qiskit gate)</li> <li><code>cx</code> (native Qiskit gate)</li> <li><code>ccx</code> (native Qiskit gate)</li> </ul> <p>This gate set is universal, meaning any gate in a circuit can be decomposed into a series of the gates above when transpiling the circuit for this backend.</p> <p>Read more about supported gates here.</p>"},{"location":"backends/backends_list/logical_early/#supported-providers","title":"Supported providers","text":"<ul> <li>\u2705 <code>AliceBobLocalProvider</code></li> <li>\u2705 <code>AliceBobRemoteProvider</code></li> </ul>"},{"location":"backends/backends_list/logical_early/#connectivity","title":"Connectivity","text":"<p>As a logical backend, this backend features all-to-all connectivity.</p>"},{"location":"backends/backends_list/logical_early/#expected-performance","title":"Expected performance","text":"<p>This backend features an error model based on theoretical papers. It is not meant to accurately reproduce a specific current or future Alice &amp; Bob chip.</p> <p>The formulas and references we used are documented in the source code at https://github.com/Alice-Bob-SW/qiskit-alice-bob-provider/blob/main/qiskit_alice_bob_provider/processor/logical_cat.py</p>"},{"location":"backends/backends_list/logical_early/#availability-schedule","title":"Availability schedule","text":"<p>As an emulator, this backend is expected to be available 24/7.</p> <p>Live status for backends is available at https://api-gcp.alice-bob.com/console/status.</p>"},{"location":"backends/backends_list/logical_noiseless/","title":"40 logical qubits, noiseless","text":"<p>Backend name : <code>EMU:40Q:LOGICAL_NOISELESS</code></p> <p>Backend type : Emulator, logical</p>"},{"location":"backends/backends_list/logical_noiseless/#about-this-backend","title":"About this backend","text":"<p><code>EMU:40Q:LOGICAL_NOISELESS</code> is a noiseless backend featuring the same native gate set as the other logical backends, but without a noise model.</p> <p>It is meant to study the quality of your transpilation, as it runs faster than the other noisy backends.</p>"},{"location":"backends/backends_list/logical_noiseless/#supported-backend-parameters","title":"Supported backend parameters","text":"<p>This backend does not have parameters, since it does not have a noise model.</p>"},{"location":"backends/backends_list/logical_noiseless/#supported-gates","title":"Supported gates","text":"<ul> <li><code>initialize</code> (custom Felis gate)</li> <li><code>measure_x</code> (custom Felis gate)</li> <li><code>delay</code> (native Qiskit gate)</li> <li><code>x</code> (native Qiskit gate)</li> <li><code>z</code> (native Qiskit gate)</li> <li><code>measure</code> (native Qiskit gate)</li> <li><code>t</code> (native Qiskit gate)</li> <li><code>tdg</code> (native Qiskit gate)</li> <li><code>h</code> (native Qiskit gate)</li> <li><code>s</code> (native Qiskit gate)</li> <li><code>sdg</code> (native Qiskit gate)</li> <li><code>cx</code> (native Qiskit gate)</li> <li><code>ccx</code> (native Qiskit gate)</li> </ul> <p>This gate set is universal, meaning any gate in a circuit can be decomposed into a series of the gates above when transpiling the circuit for this backend.</p> <p>Read more about supported gates here.</p>"},{"location":"backends/backends_list/logical_noiseless/#supported-providers","title":"Supported providers","text":"<ul> <li>\u2705 <code>AliceBobLocalProvider</code></li> <li>\u2705 <code>AliceBobRemoteProvider</code></li> </ul>"},{"location":"backends/backends_list/logical_noiseless/#connectivity","title":"Connectivity","text":"<p>As a logical backend, this backend features all-to-all connectivity.</p>"},{"location":"backends/backends_list/logical_noiseless/#expected-performance","title":"Expected performance","text":"<p>This backend doesn't feature a noise model.</p>"},{"location":"backends/backends_list/logical_noiseless/#availability-schedule","title":"Availability schedule","text":"<p>As an emulator, this backend is expected to be available 24/7.</p> <p>Live status for backends is available at https://api-gcp.alice-bob.com/console/status.</p>"},{"location":"backends/backends_list/logical_target/","title":"40 logical qubits","text":"<p>Backend name : <code>EMU:40Q:LOGICAL_TARGET</code></p> <p>Backend type : Emulator, logical</p>"},{"location":"backends/backends_list/logical_target/#about-this-backend","title":"About this backend","text":"<p><code>EMU:40Q:LOGICAL_TARGET</code> reproduces what might be the behavior of a mature logical chip, featuring 40 logical qubits. It is built using optimistic (but not unrealistic) hypotheses on qubit quality, taken from this paper and a distance 15 repetition code.</p> <p>Just like for <code>EMU:15Q:LOGICAL_EARLY</code>, physical qubit behavior is abstracted, you get all-to-all connectivity and a universal gate set.</p> <p>Error rates are extremely low (about \\(10^{-16}\\)), so this backend should be virtually impossible to distinguish from a noiseless backend when running short circuits. If you wish to use a truly noiseless backend, consider using <code>EMU:40Q:LOGICAL_NOISELESS</code> instead.</p> <p>This backend is well-suited to studying fault-tolerant algorithms on small instances of problems.</p> <p>\u26a0\ufe0f Although this backend makes it possible to choose from 40 different qubits, using it to run circuits using more than ~10-15 qubits will likely be slow or fail altogether. The exact limit depends on the capabilities of your machine.</p> <p>By the time we have real chips featuring such low error rates, we will likely have much more than 40 logical qubits. But you\u2019ll need terabytes of memory to run a 40 qubit emulator, so we thought it didn\u2019t make sense to allow more here ;)</p>"},{"location":"backends/backends_list/logical_target/#supported-backend-parameters","title":"Supported backend parameters","text":"<ul> <li><code>average_nb_photons</code><ul> <li>Default value: 19</li> <li>Supported values: 4 and above</li> </ul> </li> <li><code>distance</code><ul> <li>Default value: 15</li> <li>Supported values: 3 and above, odd integers only</li> </ul> </li> <li><code>kappa_1</code><ul> <li>Default value: 100</li> <li>Supported values: 10 and above</li> </ul> </li> <li><code>kappa_2</code><ul> <li>Default value: 10 000 000</li> <li>Supported values: 100 and above</li> </ul> </li> </ul> <p>\ud83d\udca1 The <code>kappa_1 / kappa_2</code> ratio must be between 1e-7 and 1e-1</p> <p>Read more about backend parameters here</p>"},{"location":"backends/backends_list/logical_target/#supported-gates","title":"Supported gates","text":"<ul> <li><code>initialize</code> (custom Felis gate)</li> <li><code>measure_x</code> (custom Felis gate)</li> <li><code>delay</code> (native Qiskit gate)</li> <li><code>x</code> (native Qiskit gate)</li> <li><code>z</code> (native Qiskit gate)</li> <li><code>measure</code> (native Qiskit gate)</li> <li><code>t</code> (native Qiskit gate)</li> <li><code>tdg</code> (native Qiskit gate)</li> <li><code>h</code> (native Qiskit gate)</li> <li><code>s</code> (native Qiskit gate)</li> <li><code>sdg</code> (native Qiskit gate)</li> <li><code>cx</code> (native Qiskit gate)</li> <li><code>ccx</code> (native Qiskit gate)</li> </ul> <p>This gate set is universal, meaning any gate in a circuit can be decomposed into a series of the gates above when transpiling the circuit for this backend.</p> <p>Read more about supported gates here.</p>"},{"location":"backends/backends_list/logical_target/#supported-providers","title":"Supported providers","text":"<ul> <li>\u2705 <code>AliceBobLocalProvider</code></li> <li>\u2705 <code>AliceBobRemoteProvider</code></li> </ul>"},{"location":"backends/backends_list/logical_target/#connectivity","title":"Connectivity","text":"<p>As a logical backend, this backend features all-to-all connectivity.</p>"},{"location":"backends/backends_list/logical_target/#expected-performance","title":"Expected performance","text":"<p>This backend features an error model based on theoretical papers. It is not meant to accurately reproduce a specific current or future Alice &amp; Bob chip.</p> <p>The formulas and references we used are documented in the source code at https://github.com/Alice-Bob-SW/qiskit-alice-bob-provider/blob/main/qiskit_alice_bob_provider/processor/logical_cat.py</p>"},{"location":"backends/backends_list/logical_target/#availability-schedule","title":"Availability schedule","text":"<p>As an emulator, this backend is expected to be available 24/7.</p> <p>Live status for backends is available at https://api-gcp.alice-bob.com/console/status.</p>"},{"location":"felis_cloud/about_felis_cloud/","title":"About Felis Cloud","text":"<p>Felis Cloud is Alice &amp; Bob's QCaaS (Quantum Computing as a Service) product.</p> <p>It lets you run quantum circuits on a real Boson 4 quantum chip hosted in Alice &amp; Bob's premises, or on cloud-based emulators.</p> <p>You may subscribe to Felis Cloud at https://console.cloud.google.com/marketplace/product/cloud-prod-0/felis-cloud.</p> <p>Usage time is billed as follows:</p> <ul> <li>Boson 4 QPU: 1 free hour every month, then $5000/hour</li> <li>Emulators: 1 free hour every month, then $25/hour</li> </ul> <p>We can customize pricing to your needs (large number of hours, access outside of public availability hours...) contact us to learn more.</p>"},{"location":"felis_cloud/connect_to_felis_cloud/","title":"Connect to Felis Cloud","text":""},{"location":"felis_cloud/connect_to_felis_cloud/#1-get-a-felis-cloud-subscription","title":"1. Get a Felis Cloud subscription","text":"<ul> <li>Visit https://console.cloud.google.com/marketplace/product/cloud-prod-0/felis-cloud and follow the steps to subscribe to Felis Cloud.</li> </ul>"},{"location":"felis_cloud/connect_to_felis_cloud/#2-get-an-api-key","title":"2. Get an API key","text":"<ul> <li>Connect to your console at https://api-gcp.alice-bob.com/console/ using the Google account you used to subscribe to Felis Cloud.</li> <li>Go the \"API KEYS\" tab to create an API key</li> </ul> <p>\ud83d\udca1 Note: If you wish to share your Felis Cloud subscription with other people, create one API key for each person. Should the need arise, this makes it easier to control billing and revoke access rights.</p>"},{"location":"felis_cloud/connect_to_felis_cloud/#3-use-your-api-key-in-the-remote-provider","title":"3. Use your API key in the remote provider","text":"<p>Instead of the <code>AliceBobLocalProvider</code> used in most examples here, use the <code>AliceBobRemoteProvider</code> together with your API key</p> <pre><code>provider = AliceBobRemoteProvider('YOUR_API_KEY')\n</code></pre> <p>You may then select backends which are only available through Felis Cloud, such as the one of the Boson 4 QPUs: Boson 4A, 4B or 4C:</p> <pre><code>backend = provider.get_backend('QPU:1Q:BOSON_4A')\n</code></pre>"},{"location":"felis_cloud/hardware_availability_schedule/","title":"Hardware availability schedule","text":""},{"location":"felis_cloud/hardware_availability_schedule/#emulators","title":"Emulators","text":"<p>All emulators in the remote provider are expected to be available 24/7.</p>"},{"location":"felis_cloud/hardware_availability_schedule/#quantum-hardware","title":"Quantum hardware","text":"<p>Boson 4 is currently offline for maintenance and will return on July 22nd.</p> Date Availability window Chip Monday, July 21st - - Tuesday, July 22nd 10am - 5pm CET <code>QPU:1Q:BOSON_4A</code> Wednesday, July 23rd 10am - 5pm CET <code>QPU:1Q:BOSON_4A</code> Thursday, July 24th 10am - 5pm CET <code>QPU:1Q:BOSON_4A</code> Friday, July 25th 10am - 5pm CET <code>QPU:1Q:BOSON_4A</code> Saturday, July 26th - - Sunday, July 27th - - Monday, July 28th 10am - 5pm CET <code>QPU:1Q:BOSON_4A</code> Tuesday, July 29th 10am - 5pm CET <code>QPU:1Q:BOSON_4A</code> Wednesday, July 30th 10am - 5pm CET <code>QPU:1Q:BOSON_4A</code> Thursday, July 31st 10am - 5pm CET <code>QPU:1Q:BOSON_4A</code> Friday, August 1st 10am - 5pm CET <code>QPU:1Q:BOSON_4A</code> Saturday, August 2nd - - Sunday, August 3rd - - <p>Live status for backends is available at https://api-gcp.alice-bob.com/console/status.</p> <p>\ud83d\udca1 Note: We might need to take down the chip at any moment without advance notice. Should this happen, we will update this page and give more information in our Slack community, The Cat Tree.</p> <p>If you would like to run experiments outside of the public availability schedule, we are happy to explore custom solutions, please contact us.</p>"},{"location":"felis_cloud/run_multiple_circuits/","title":"How to run multiple circuits remotely","text":"<p>When sweeping over some parameters (for example, the number of photons in the cat), it is much faster to send all the circuits to the Alice &amp; Bob Felis cloud service and then wait for the results:</p> <pre><code>from qiskit_alice_bob_provider import AliceBobRemoteProvider\nfrom qiskit import QuantumCircuit\n\n# Replace the placeholder with your actual API key in the line below\nremote = AliceBobRemoteProvider(api_key='YOUR_API_KEY')\nbackend = remote.get_backend('BACKEND_NAME')\n\ncirc = QuantumCircuit(1, 1)\ncirc.reset(0)\ncirc.delay(1, 0, unit='ms')\ncirc.measure(0, 0)\n\njobs = []\nshots = 1_000\nfor nb_photons in range(2, 11):\n    jobs.append(backend.run(circ, shots=shots, average_nb_photons=nb_photons))\n\nresults = [job.result() for job in jobs]\n# for example, computing the number of bit flips:\nflip_fractions = [r.get_counts().get('1', 0) / shots for r in results]\n</code></pre> <p>That\u2019s because the API can run some parts of the processing in parallel. It also minimizes the number of network calls.</p> <p>\u26a0\ufe0f Here\u2019s an example of what you should not do:</p> <pre><code># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n# Don't do this! This is much slower than the code snippet above.\n# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\nfrom qiskit_alice_bob_provider import AliceBobRemoteProvider\nfrom qiskit import QuantumCircuit\n\n# Replace the placeholder with your actual API key in the line below\nremote = AliceBobRemoteProvider(api_key='YOUR_API_KEY')\nbackend = remote.get_backend('BACKEND_NAME')\n\ncirc = QuantumCircuit(1, 1)\ncirc.reset(0)\ncirc.delay(1, 0, unit='ms')\ncirc.measure(0, 0)\n\nshots = 1_000\nresults = []\nfor nb_photons in range(2, 11):\n    job = backend.run(circ, shots=shots, average_nb_photons=nb_photons)\n    results.append(job.result())\n\n# for example, computing the number of bit flips:\nflip_fractions = [r.get_counts().get('1', 0) / shots for r in results]\n</code></pre>"},{"location":"getting_started/install_the_qiskit_provider/","title":"Install the Qiskit provider","text":""},{"location":"getting_started/install_the_qiskit_provider/#1-set-up-your-environment","title":"1. Set up your environment","text":"<p>You need a Python environment to use Felis (supported Python versions: 3.8 to 3.11).</p> <p>We strongly recommend creating a new environment before attempting to install Felis. We assume you know how to do this. If you don\u2019t, you can go through the Python docs, or simply reach out.</p>"},{"location":"getting_started/install_the_qiskit_provider/#2-install-the-alice-bob-qiskit-provider","title":"2. Install the Alice &amp; Bob Qiskit provider","text":"<pre><code>pip install --upgrade qiskit-alice-bob-provider\n</code></pre> <p>\ud83d\udcdd Note: no need to install Qiskit separately, it will be installed automatically if it is not already installed.</p> <p>\u26a0\ufe0f Warning: Felis is currently only compatible with Qiskit 1.x, starting with 1.3.1. If you have a more recent version of Qiskit (2.0 or higher), you will need to create a new environment before installing Felis.</p>"},{"location":"getting_started/install_the_qiskit_provider/#3-write-your-first-qiskit-program","title":"3. Write your first Qiskit program","text":"<p>To use the Alice &amp; Bob Qiskit provider in a Qiskit program, you need to instantiate it and retrieve a backend.</p> <pre><code>from qiskit_alice_bob_provider import AliceBobLocalProvider\nab = AliceBobLocalProvider()\n\nprint(ab.backends())\nbackend = ab.get_backend('EMU:1Q:LESCANNE_2020')\n</code></pre> <p>You may then use <code>backend</code> as a target to execute a Qiskit circuit.</p> <pre><code>from qiskit import QuantumCircuit\n\ncirc = QuantumCircuit(1,1)\ncirc.reset(0)\ncirc.measure(0, 0)\njob = backend.run(circ, shots=1_000)\nres = job.result()\nprint(res.get_counts())\n</code></pre> <p>\ud83d\udcdd Note: If you\u2019re not familiar with Qiskit, we recommend reading this short introduction.</p>"},{"location":"getting_started/install_the_qiskit_provider/#4-enjoy","title":"4. Enjoy!","text":"<p>Now that you understand the basics, you need to know that Felis features both physical and logical backends:</p> <ul> <li>Physical backends reproduce the behavior of individual, physical cat qubits; use them to study quantum error correction or the properties of cat qubits</li> <li>Logical backends reproduce the behavior of logical qubits created out of several cat qubits running a quantum error correction code; use them to run quantum algorithms and study the impact of noise on the quality of their results</li> </ul> <p>To go further, check out and compare these two examples:</p> <ul> <li>An example with physical qubits, which shows a core property of cat qubits</li> <li>An example with logical qubits, which creates a Bell state on logical qubits</li> </ul> <p>\ud83d\udcdd Note: unless otherwise stated, our examples all use <code>AliceBobLocalProvider</code>, which runs the circuits on your own machine. In order to run circuits on a real quantum chip or on cloud-based emulators, you need to use the <code>AliceBobRemoteProvider</code> and have a Felis Cloud subscription.</p>"},{"location":"getting_started/logical_example/","title":"An example with logical qubits","text":"<p>When you use a logical backend, you get error-corrected qubits with all-to-all connectivity and a universal gate set.</p> <p>Logical backends are less noisy than physical backends, but they still feature noise. You may tune the backend's noise characteristics using parameters <code>distance</code>, <code>kappa_1</code>, <code>kappa_2</code> and <code>average_nb_photons</code> (read Supported instructions for more details about these parameters and how to set them).</p> <p>For the time being, logical backends are all emulators, but creating a QPU able to run in logical mode is Alice &amp; Bob's main goal.</p> <p>Here's an example using a logical backend, showing how continuous gates are decomposed into discrete gates.</p> <p>We start by getting one of the two logical backends (<code>EMU:15Q:LOGICAL_EARLY</code>).</p> <pre><code>from qiskit_alice_bob_provider import AliceBobLocalProvider\nfrom qiskit import QuantumCircuit, transpile\nimport numpy as np\n\nab = AliceBobLocalProvider()\n\nbackend = ab.get_backend('EMU:15Q:LOGICAL_EARLY')\n</code></pre> <p>We then apply a <code>rx</code> gate, which is not supported by physical backends as it is not bias-preserving, and which is not a native logical operation either.</p> <pre><code>circ = QuantumCircuit(1,1)\ncirc.rx(np.pi / 8.0, 0)\ncirc.measure(0,0)\n</code></pre> <p>So, when we transpile the result to our logical backend:</p> <pre><code>circ = transpile(circ, backend)\nprint(circ)\n</code></pre> <p>We get the following circuit using only native logical gates:</p> <pre><code>     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u00bb\n   q \u2524 Initialize(0) \u251c\u2524 Tdg \u251c\u2524 H \u251c\u2524 T \u251c\u2524 H \u251c\u2524 Tdg \u251c\u2524 H \u251c\u2524 Tdg \u251c\u2524 H \u251c\u2524 T \u251c\u2524 T \u251c\u00bb\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u00bb\nc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\n                                                                              \u00bb\n\u00ab     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u00bb\n\u00ab   q \u2524 T \u251c\u2524 T \u251c\u2524 H \u251c\u2524 Tdg \u251c\u2524 H \u251c\u2524 Tdg \u251c\u2524 H \u251c\u2524 T \u251c\u2524 H \u251c\u2524 Tdg \u251c\u2524 H \u251c\u2524 T \u251c\u2524 H \u251c\u00bb\n\u00ab     \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u00bb\n\u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\n\u00ab                                                                            \u00bb\n\u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\n\u00ab   q \u2524 Tdg \u251c\u2524 H \u251c\u2524 Tdg \u251c\u2524 H \u251c\u2524 Tdg \u251c\u2524 H \u251c\u2524 T \u251c\u2524 H \u251c\u2524 T \u251c\u2524 T \u251c\u2524 T \u251c\u2524 H \u251c\u2524 Tdg \u251c\u00bb\n\u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\n\u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\n\u00ab                                                                              \u00bb\n\u00ab     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u00bb\n\u00ab   q \u2524 H \u251c\u2524 T \u251c\u2524 H \u251c\u2524 T \u251c\u2524 H \u251c\u2524 Tdg \u251c\u2524 Tdg \u251c\u2524 Tdg \u251c\u2524 H \u251c\u2524 Tdg \u251c\u2524 H \u251c\u2524 T \u251c\u2524 H \u251c\u00bb\n\u00ab     \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u00bb\n\u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\n\u00ab                                                                              \u00bb\n\u00ab     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n\u00ab   q \u2524 T \u251c\u2524 H \u251c\u2524 T \u251c\u2524 H \u251c\u2524 Tdg \u251c\u2524 H \u251c\u2524 Tdg \u251c\u2524M\u251c\n\u00ab     \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518\n\u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\n\u00ab                                             0 \n</code></pre> <p>This circuit may then be executed like any Qiskit circuit:</p> <pre><code>job = backend.run(circ, shots=1_000)\nprint(job.result().get_counts())\n</code></pre> <p>\ud83d\udca1 Note: <code>backend.run()</code> transpiles your circuit if you didn't do it manually, but transpiling yourself enables you to examine the circuit which is actually executed.</p> <p>Use logical backends to run quantum algorithms.</p> <p>Don't hesitate to play with the <code>distance</code>, <code>kappa_1</code>, <code>kappa_2</code> and <code>average_nb_photons</code> settings to change the noise characteristics of your backend and study how this affects your results.</p> <p>You may: - Read Supported instructions for more details about these parameters and how to set them) - Check out our sample notebook showing how to perform this study</p> <p>\ud83d\udca1 Note: As you'll notice above, circuits are transpiled to Clifford + T gates, but our logical backends also natively support Toffoli gates. We are considering using the Clifford + Toffoli gate set instead of Clifford + T for some applications. While the transpilation engine does not (yet) compile to this gate set, you are free to develop your own engine and try it out using our logical backends!</p>"},{"location":"getting_started/physical_example/","title":"An example with physical qubits","text":"<p>When you use a physical backend, qubit and gates feature the noise characteristics of physical cat qubits. In other words, each qubit of a physical backend corresponds to one qubit on a chip (real or emulated).</p> <p>Cat qubits feature a strongly biased noise: their bit-flip lifetime can be very long (up to hundreds of seconds), but their phase-flip lifetime is relatively short (a few microseconds).</p> <p>This property greatly reduces the number of qubits required to implement quantum error correction, up to 200 times as shown in this article.</p> <p>\ud83d\udca1 Note: If you\u2019re not familiar with cat qubits, you may want to read Working with cat qubits: similarities &amp; differences first.</p> <p>Here's an example using a physical backend, showing how cat qubits feature a biased noise.</p> <p>First, we set up the provider and import dependencies:</p> <pre><code>from qiskit import QuantumCircuit\nfrom qiskit.visualization import plot_histogram\nfrom qiskit_alice_bob_provider import AliceBobLocalProvider\n\nab = AliceBobLocalProvider()\n</code></pre> <p>Then, we pick a backend to use:</p> <pre><code>print(ab.backends())\nbackend = ab.get_backend('EMU:1Q:LESCANNE_2020')\n</code></pre> <p>Then, we design and execute a simple circuit sensitive to bit-flips (Prepare \\(\\ket{0}\\) / Wait / Measure on the Z axis), whose result would always be 0 in a noiseless environment:</p> <pre><code># Measure bit-flip errors after 1\u00b5s\nc1 = QuantumCircuit(1, 1)\nc1.delay(1, unit='us')\nc1.measure(0, 0)\njob1 = backend.run(c1, shots=1000, average_nb_photons=3)\nres1 = job1.result()\nplot_histogram(res1.get_counts())\n</code></pre> <p>Then, we replicate the same idea to design and execute a circuit sensitive to phase-flips (Prepare \\(\\ket{+}\\) / Wait / Measure on the X axis), whose result should also always be 0 in a noiseless environment:</p> <pre><code># Measure phase-flip errors after 1 \u00b5s\nc2 = QuantumCircuit(1, 1)\nc2.initialize('+', 0)\nc2.delay(1, unit='us')\nc2.measure_x(0, 0)\njob2 = backend.run(c2, shots=1000, average_nb_photons=3)\nres2 = job2.result()\nplot_histogram(res2.get_counts())\n</code></pre> <p>The second circuit should show far more errors than the first, showing our qubits do have a noise bias: they are strongly protected against bit-flip errors.</p> <p>Come and show us your results!</p>"},{"location":"getting_started/physical_example/#going-further","title":"Going further","text":"<p>Now that you understand how things work, you can start having fun.</p> <p>Here are some ideas of experiments you can run:</p> <ul> <li>Showcase exponential suppression of bit-flips by varying <code>average_nb_photons</code></li> <li>Showcase linear increase of the phase-flip rate by varying <code>average_nb_photons</code></li> <li>Measure the bit-flip time</li> <li>Measure the phase-flip time</li> </ul> <p>In order to implement these ideas, have a look at the list of Supported instructions.</p> <p>You may also look at our sample notebooks for more inspiration.</p>"},{"location":"getting_started/sample_notebooks/","title":"Sample notebooks","text":"<p>A set of introductory notebooks is available in the following repository:</p> <p>https://github.com/Alice-Bob-SW/felis/tree/main/samples</p> <p>We recommend starting with these examples!</p>"},{"location":"getting_started/why_cat_qubits/","title":"What is a cat qubit? What is it good for?","text":"<p>Cat qubits are superconducting qubits which are particularly well-suited to implementing error correction, since they can advantageously trade bit-flip errors for phase-flip errors.</p> <p>When tuning a specific parameter (the average number of the photons in the cat qubit), the frequency of bit-flip errors decreases exponentially, while the frequency of phase-flip errors increases only linearly.</p> <p>This \u201cbiased noise\u201d makes it possible to virtually eliminate bit-flip errors, while keeping phase-flip errors below the error correction threshold.</p> <p>This in turn enables much simpler error correction schemes: because there\u2019s virtually only one type of error to correct, you can use a simple repetition code, instead of a surface code that requires far more qubits.</p> <p>Several physical qubits running a repetition code can then become a \u201clogical qubit\u201d, featuring a much lower error rate than any of the physical qubits it is made of.</p> <p>Using cat qubits, we estimate we can build a fault-tolerant quantum computer requiring 60 times fewer or even 200 times fewer qubits than if we were using transmons.</p> <p>To learn more about the physics of cat qubits, you can read our seminal paper at https://www.nature.com/articles/s41567-020-0824-x or https://arxiv.org/abs/1907.11729.</p>"},{"location":"getting_started/working_with_cat_qubits/","title":"Working with cat qubits: similarities &amp; differences","text":"<p>In this page, we assume that you are familiar with transmon qubits like the ones found in IBM systems, and that you have already run circuits using Qiskit.</p> <p>If this is the case, here is a pragmatic summary of what to expect with Felis.</p>"},{"location":"getting_started/working_with_cat_qubits/#what-stays-the-same","title":"What stays the same:","text":"<ul> <li>You design and run quantum circuits made out of gates and qubits using Qiskit</li> <li>You can use most if not all of the gates you are used to (at least in logical mode, see below)</li> <li>Your circuits can be run on emulators or real hardware (although real hardware requires a specific Felis Cloud subscription)</li> </ul>"},{"location":"getting_started/working_with_cat_qubits/#what-is-different","title":"What is different:","text":"<ul> <li>There are two types of backends: physical and logical<ul> <li>Physical backends:<ul> <li>Reproduce the behavior of physical cat qubits, therefore exhibiting a strong noise bias (low bit-flip error rates, high phase-flip error rates)</li> <li>May not be used to run quantum algorithms, because they feature a limited set of gates and limited connectivity</li> <li>May be used to study quantum error correction or the properties of cat qubits</li> </ul> </li> <li>Logical backends:<ul> <li>Reproduce the behavior of logical qubits created out of several cat qubits running a quantum error correction code; noise bias may still be present but less so than with physical backends </li> <li>May be used to run quantum algorithms and study the impact of noise on the quality of their results; they feature a universal set of gates and all-to-all connectivity</li> <li>Abstract away error correction, but let you tune its effect by using the <code>distance</code> parameter </li> </ul> </li> <li>Learn more about logical and physical backends here</li> </ul> </li> <li>With both types:<ul> <li>The bit-flip/phase-flip ratio can be tuned by adjusting <code>average_nb_photons</code></li> <li>Additional native operations are available (prepare \\(\\ket{+}\\) or \\(\\ket{-}\\), measurement along the X axis); learn about them here</li> <li>Emulator backends which are not digital twins let you tune <code>kappa_1</code> and <code>kappa_2</code> parameters, representing the quality of the cat qubit (a good cat qubit has a low <code>kappa_1</code> and a high <code>kappa_2</code>)</li> <li>Learn more about cat qubits and their figures of merit here</li> </ul> </li> </ul>"},{"location":"reference/about_the_provider/","title":"About the Qiskit provider","text":"<p>Alice &amp; Bob\u2019s Qiskit provider is an open-source project which can be accessed via the following link:</p> <p>https://github.com/Alice-Bob-SW/qiskit-alice-bob-provider</p>"},{"location":"reference/boson_4_chips/","title":"Boson 4 chips","text":""},{"location":"reference/boson_4_chips/#the-boson-4-design","title":"The Boson 4 design","text":"<p>Boson 4 is part of the \u201cBoson\u201d series of chip designs, meant to demonstrate promising ways of implementing cat qubits.</p> <p></p> <p>Just like its two predecessors, Boson 4 is a transmon-free design. This enables it to reach very long bit-flip lifetimes (up to 430 seconds).</p> <p>As its name suggests, Boson 4 follows three previous designs:</p> <ul> <li>Boson 1 (arXiv link) is the design which started Alice &amp; Bob. It demonstrated the possibility to exponentially suppress bit-flips, while only linearly increasing phase-flips. Its bit-flip lifetime however saturated at 1 ms, due to the presence of a transmon in the experimental setup.</li> <li>Boson 2 showed it is possible to take bit-flip lifetime up to 100 seconds by removing the transmon from the setup. This design however lacked the possibility to measure phase-flips.</li> <li>Boson 3 (arXiv link) improved upon Boson 2 by introducing a new readout protocol making it possible to do transmon-free measurements along the X and the Z axis. Its bit-flip lifetime reached over 10 seconds.</li> </ul> <p>Boson 4 uses the same readout protocols as Boson 3, but manages to reach longer bit-flip lifetimes than any of its predecessors.</p> <p>A Boson 4 chip features two independent cat qubits, which are not coupled with one another.</p> <p>We are currently working on a paper giving a more detailed description of the Boson 4 design.</p>"},{"location":"reference/boson_4_chips/#available-boson-4-backends","title":"Available Boson 4 backends","text":"<p>You may run circuits on a Boson 4 chip using one of the three Boson 4 backends (Felis Cloud subscription required).</p>"},{"location":"reference/boson_4_chips/#main-performance-figures","title":"Main performance figures","text":"<p>The figures below can all be reproduced using this notebook</p> <p>\ud83d\udca1 Note: The figures below were measured on Boson 4A. While Boson 4B and 4C feature similar performance, slight differences may exist.</p>"},{"location":"reference/boson_4_chips/#lifetime","title":"Lifetime","text":"<p>These figures represent the qubit's bit-flip and phase-flip lifetime.</p> <p>When preparing the \\(\\ket{0}\\) state, the probability of the Pauli operator Z yielding 0 after a delay of duration \\(t\\) decays as \\(\\exp(-t/T_{Z})\\), where \\(T_{Z}\\) is the bit-flip lifetime.</p> <p>When preparing the \\(\\ket{+}\\) state, the probability of the Pauli operator X yielding +1 after a delay of duration \\(t\\) decays as \\(\\exp(-t/T_{X})\\), where \\(T_{X}\\) is the phase-flip lifetime.</p> average_nb_photons = 4 average_nb_photons = 11 Bit-flip \\(830 \u00b5s\\) \\(120 s\\) Phase-flip \\(0.95 \u00b5s\\) \\(0.3 \u00b5s\\) <p>\ud83d\udca1 Note: Measuring lifetimes over 100 seconds is challenging using repeated measurements and a chip shared between users:</p> <ul> <li>Doing 1000 shots of a 100-second experiment takes almost 28 hours</li> <li>Doing shorter experiments yields too few errors; this requires using more shots and does not make experiments significantly shorter</li> </ul> <p>We are working on adding the \u201creal-time trajectories\u201d protocol described in our latest Nature paper (arXiv link), which enables shorter measurements.</p> <p>\ud83d\udca1 Note: if you're used to working with transmons, you know that state decay only happens if you start from the \\(\\ket{1}\\) state. With cat qubits, the \\(\\ket{0}\\) and \\(\\ket{1}\\) states are virtually interchangeable. Experimental differences might remain, but they're mostly due to sampling noise, calibration inaccuracies or readout.</p>"},{"location":"reference/boson_4_chips/#spam-errors","title":"SPAM errors","text":"<p>These figures represent sequence error (# shots giving the wrong result / # of shots).</p> Sequence average_nb_photons = 4 average_nb_photons = 11 \\(P_0\\) - \\(M_Z\\) \\(1.7\\%\\) \\(7.6\\times 10^{-6}\\) \\(P_+\\) - \\(M_X\\) \\(40 \\%\\) \\(47 \\%\\) <p>\ud83d\udca1 Note: If you run your own experiments, you will notice that \\(P_1\\) - \\(M_Z\\) does not give the same results as \\(P_0\\) - \\(M_Z\\). This is because while our state preparation is symmetrical, our readout protocol is not.</p>"},{"location":"reference/boson_4_chips/#z-gate-performance","title":"Z gate performance","text":"<p>These figures represent the probability of getting a bit-flip or phase-flip during a Z-gate.</p> average_nb_photons = 4 average_nb_photons = 11 Bit-flip \\(5.0 \\times 10^{-4}\\) \\(5.8 \\times 10^{-8}\\) Phase-flip \\(22 \\%\\) \\(27 \\%\\) <p>\ud83d\udca1 Note: As you'll notice, while this chip's bit-flip performance is stellar, the phase-flip performance is still somewhat underwhelming.</p> <p>A few things to keep in mind when reading these results:</p> <ul> <li>The readout protocol has not been optimized and can still be further improved.</li> <li>Better performance has already been achieved with different designs. For example, the AutoCat design features a 3.5 % error rate for the Z gate.</li> <li>Cat qubit architectures are less demanding regarding qubit quality (a repetition code has a higher threshold than a surface code).</li> </ul> <p>Overall, phase-flip performance still needs to improve by 1 to 2 orders of magnitude for error correction to work reliably. More precisely:</p> <ul> <li>According to this paper, the \\(\\kappa_2/\\kappa_{1_{eff}}\\) ratio must be improved to a few hundreds to reach the repetition code's threshold.</li> <li>According to the figures in the table below, Boson 4's ratio is 12.5.</li> </ul> <p>We are focused on improving these figures, with several promising solutions being tested in our lab. Stay tuned!</p> <p>Or, if you think this is an interesting research topic, don't hesitate to drop us a line, we are happy to explore potential collaborations.</p>"},{"location":"reference/boson_4_chips/#chip-parameters","title":"Chip parameters","text":"<p>These parameters were measured in Alice &amp; Bob\u2019s lab and cannot be reproduced using Felis.</p> Metric Measured value Description \\(f_a\\) 1.079 GHz Memory resonator frequency \\(f_b\\) 7.898 GHz Buffer resonator frequency \\(\\kappa_1/2\\pi\\) 2.26\u00a0kHz Memory resonator energy relaxation rate / single-photon loss rate \\(\\kappa_{1_{eff}}/2\\pi\\) 19.9 kHz Effective \\(\\kappa_1\\) experienced by the cat qubit \\(\\kappa_b/2\\pi\\) 22\u00a0MHz Buffer resonator energy relaxation rate / single-photon loss rate \\(\\kappa_2/2\\pi\\) 250 kHz Engineered memory resonator two-photon dissipation rate \\(g_2/2\\pi\\) 1.2\u00a0MHz Hamiltonian two-photon exchange rate in between memory and buffer resonators \\(K/2\\pi\\) -12 kHz Thermal population of the memory resonator \\(\\kappa_\u03c6/2\\pi\\) &lt; 10\u00a0kHz Memory resonator pure dephasing rate \\(n_{th}\\) 2 Self-Kerr / anharmonicity of the memory resonator <p>For more details about what these parameters mean, read our seminal Nature Physics paper (arXiv link).</p>"},{"location":"reference/boson_4_chips/#gate-implementation-details","title":"Gate implementation details","text":"<p>There are three types of gates available: </p> <ul> <li>\"preparation gates\" (\\(P_0\\), \\(P_1\\), \\(P_+\\), \\(P_-\\)), used to initialize the state of the cat on some remarkable spots on the Bloch sphere;</li> <li>\"one-qubit operations\" (\\(Z\\), \\(I\\)), used to transform one state into an other one</li> <li>\"measurement gates\" (\\(M_X\\), \\(M_Z\\)), used to measure the state of the qubit.</li> </ul> <p></p> <p>Bloch sphere for cat qubits. The Z basis states is constituted from the stable coherent state, while the X axis basis is constituted from the even and odd cat states.</p> <p>For cat qubits, the basis states along the Z axis and the X axis are not equivalent. Indeed, the states along Z are stable (long lived) since they are protected by the two-photon dissipation process, while the states along the X axis are not protected: their lifetime is given by the lifetime of the memory under pump.</p> <p>Therefore, we can regroup the available gates into two families: the Z family associated to the the Z basis (\\(P_0\\), \\(P_1\\), \\(I\\), \\(M_Z\\)), and the X family associated to the X basis (\\(P_+\\), \\(P_-\\), \\(Z\\), \\(I\\), \\(M_X\\)).</p> <p>Furthermore, each of these gates should be ''bias preserving'', which means that they preserve the high stability of the Z axis. In the following, we present each of these gates according to the Z and X family classification.  </p>"},{"location":"reference/boson_4_chips/#initialize0-or-1","title":"<code>initialize('0' or '1')</code>","text":"<p>The preparation of the states \\(\\left|0\\right\\rangle\\) and \\(\\left|1\\right\\rangle\\) is done by displacing the memory from the vacuum state to the given locations \\(\\alpha\\) and \\(-\\alpha\\) respectively in phase space. This displacement is achieved by driving the memory resonantly while the two photon stabilization is turned off, for a given fixed duration and complex amplitude.</p> <p></p> <p>Pulse sequence for preparing \\(\\left|0\\right\\rangle\\) and \\(\\left|1\\right\\rangle\\) with a resonant drive on the memory.</p>"},{"location":"reference/boson_4_chips/#initialize","title":"<code>initialize('+')</code>","text":"<p>Preparing the cat state \\(\\left|+\\right\\rangle\\) is done by ''inflation from vacuum.'' Starting from an empty memory, we turn on the two photon stabilization and the buffer drive, thereby leading to a stabilized cat state for timescales greater than \\(1 /\\kappa_2\\) : this process is called an ''inflation''. Since the parity of the state is preserved through this process, the stabilized cat state will be the even cat state \\(\\left|+\\right\\rangle\\). </p> <p> </p> <p>Pulse sequence for preparing the even cat \\(\\left|+\\right\\rangle\\), and the corresponding Wigner figure</p>"},{"location":"reference/boson_4_chips/#initialize-","title":"<code>initialize('-')</code>","text":"<p>Preparing the odd cat state \\(\\left|-\\right\\rangle\\) is done by applying a gate $Z_{\\pi} $ to the even cat state \\(\\left|+\\right\\rangle\\). </p> <p>Pulse sequence for preparing \\(\\ket{-}\\)</p>"},{"location":"reference/boson_4_chips/#measure0","title":"<code>measure(0)</code>","text":"<p>Given a state \\(\\left|\\psi\\right\\rangle = a \\left|0\\right\\rangle + b\\left|1\\right\\rangle = a \\left|\\alpha\\right\\rangle + b\\left|-\\alpha\\right\\rangle + O\\left(e^{-2|\\alpha|^2}\\right)\\), the measurement of Z is done using the ''Cat Longitudinal Readout'' (CaLoR) protocol. It consists in turning off the 2 photon pump, then displacing the resulting state by \\(+\\alpha\\), and finally reading out the number of photons. Read more about it in our latest Nature paper (arXiv link).</p> <p>The result of the displacement is a state \\(\\left|\\psi'\\right\\rangle \\equiv D(\\alpha)\\left|\\psi\\right\\rangle = a \\left| 2\\alpha \\right\\rangle + b\\left|0\\right\\rangle\\). Reading out the number of photons of \\(\\left|\\psi'\\right\\rangle\\) yields the number $4 |\\alpha|^2 |a|^2 $, which directly relates to \\(\\left\\langle \\psi' |Z| \\psi' \\right \\rangle = |a|^2 - |b|^2 = 2 |a|^2 - 1\\) (recall that $|\\alpha|^2 $ is a fixed quantity). Note that this measurement is destructive: it does not preserve the state, so the cat is dead after this readout!  </p> <p></p> <p>Pulse sequence for the \\(M_Z\\) measurement gate</p>"},{"location":"reference/boson_4_chips/#measure_x0","title":"<code>measure_x(0)</code>","text":"<p>Parity measurement is done by mapping the parity basis to the logical basis via a $Y_{\\frac{\\pi}{2}} = X_{\\frac{\\pi}{2}} Z_{\\frac{\\pi}{2}} $ gate \\(\\{\\left|+\\right\\rangle, \\left|-\\right\\rangle\\}  \\rightarrow \\{\\left|0\\right\\rangle, \\left|1\\right\\rangle\\}\\) . In practice this is realized through the ''Holonomic sequence'' which consists of a $Z_{\\frac{\\pi}{2}} $gate followed by a deflate and orthogonal inflate. Read more about this sequence in our latest Nature paper (arXiv link).</p> <p> </p> <p>Pulse sequence and Wigner figures for the \\(M_X\\) measurement gate</p>"},{"location":"reference/boson_4_chips/#z0","title":"<code>z(0)</code>","text":"<p>The Zeno gate allows to change the phase \\(\\phi\\) of the logical states superposition \\(\\frac{\\left|0\\right\\rangle + e^{i\\phi} \\left|1\\right\\rangle}{2}\\), and thus for example change the parity of a cat state, since \\(Z_{\\pi} \\left|+\\right\\rangle = \\left|-\\right\\rangle\\). Zeno gate is realized by driving the memory resonantly with a phase orthogonal to the stabilization axis, while stabilizing the memory. The resonant memory drive causes the fringes to roll with a frequency \\(\\Omega_z= 4\\alpha\\epsilon_z\\) proportional to the cat size \\(\\alpha\\) and the Zeno drive amplitude \\(\\epsilon_z\\).</p> <p> </p> <p>Pulse sequence and Wigner figure for Zeno pulse while stabilizing cat qubits</p>"},{"location":"reference/boson_4_chips/#reset0","title":"<code>reset(0)</code>","text":"<p>Resetting the memory is done by activating a so called SWAP interaction with the buffer \\(H_{\\rm SWAP} = g_1 a^\\dagger b + g_1^*a^\\dagger b\\). Since the buffer is cold and relaxes quickly to the environment, the memory will be endowed with a strong 1 photon loss mechanism, leading it to empty to the vacuum state.</p> <p></p> <p>Reset pulse sequence : it consists in a single pump tone applied for a given duration</p>"},{"location":"reference/changelog/","title":"Changelog","text":""},{"location":"reference/changelog/#version-111","title":"Version 1.1.1","text":"<p><code>get_memory</code> functionality for Remote Providers:</p> <ul> <li>When using the <code>memory=True</code> parameter in <code>backend.run</code>, the result of each individual shot is stored. It can then be retrieved using the <code>get_memory</code> function on the result of an <code>AliceBobRemoteProvider</code> job.</li> <li>This feature aligns with functionality already available in the <code>AliceBobLocalProvider</code>, ensuring consistency across providers.</li> <li>This makes it possible to use a Boson 4 chip as a random number generator, for example.</li> </ul> <p>Example</p> <p>Here\u2019s how to retrieve the memory of a quantum circuit execution:</p> <pre><code>from qiskit_alice_bob_provider import AliceBobRemoteProvider\nfrom qiskit import transpile\n\n# Initialize the remote provider\nremote_provider = AliceBobRemoteProvider('&lt;API_KEY&gt;')\n\n# Retrieve the backend and execute the circuit\nbackend = remote_provider.get_backend('&lt;backend&gt;')\ncircuit = &lt;...&gt;  # Define your quantum circuit\ntranspiled_circuit = transpile(circuit, backend)\njob = backend.run(transpiled_circuit, shots=10000, memory=True)\n\n# Retrieve the memory of the circuit\nresult = job.result()\nmemory = result.get_memory()\n\nprint(memory)\n</code></pre>"},{"location":"reference/changelog/#version-110","title":"Version 1.1.0","text":"<ul> <li>Migrated to Qiskit 1.3 :<ul> <li>Default <code>optimization_level</code> for <code>backend.transpile()</code> is changed from 1 to 2.</li> </ul> </li> <li>Transpilation now works correctly for backend targets with only Clifford + T gate basis (except for gates CRY, RCCX and RCCCX on macOS for now)</li> <li>Alice &amp; Bob custom options like <code>average_nb_photons</code> are not allowed for <code>backend.run()</code> with local provider because they will be ignored. They should be passed to <code>provider.get_backend()</code> instead.</li> <li>Drop support for Python 3.8</li> </ul>"},{"location":"reference/changelog/#version-100","title":"Version 1.0.0","text":"<ul> <li>Migrated to Qiskit 1.2 (BREAKING CHANGES for 1.0) :<ul> <li>Function <code>execute()</code> is removed in favor of <code>transpile()</code> + <code>backend.run()</code></li> <li><code>circuit.cnot()</code> gate should now be declared with <code>circuit.cx()</code></li> <li>Python environments created with previous Qiskit versions need to be recreated</li> <li>For more details about other Qiskit 1.0 changes, you can read the complete migration guide.</li> </ul> </li> <li>Specifying options for <code>get_backend()</code> no longer modifies the default    options for this backend on the Alice &amp; Bob provider Python object.</li> </ul> <p>Example to execute a circuit :</p> <pre><code># Legacy path\nfrom qiskit import execute\n\njob = execute(circuit, backend)\n\n# New path\nfrom qiskit import transpile\n\nnew_circuit = transpile(circuit, backend)\njob = backend.run(new_circuit)\n</code></pre>"},{"location":"reference/changelog/#version-072","title":"Version 0.7.2","text":"<ul> <li>Bump twine to version 5.1.1</li> </ul>"},{"location":"reference/changelog/#version-071","title":"Version 0.7.1","text":"<ul> <li>Use ipywidget to display job status on notebooks</li> </ul>"},{"location":"reference/changelog/#version-070","title":"Version 0.7.0","text":"<ul> <li>Deprecated Python 3.7 for the provider. Python 3.7 has been officially deprecated since June 27th 2023. (https://devguide.python.org/versions/) This was triggered after ARM chip users experienced issues with installing the provider since Numpy is not built for ARM Python 3.7.</li> <li>Set max version of Python to 3.11 for the provider. Python 3.12+ introduces breaking changes to setuptools. The Alice &amp; Bob team will support this version in the near future.</li> <li>Changed default remote API URL to <code>api-gcp.alice-bob.com</code> instead of <code>api.alice-bob.com</code>, following the official release of Felis Cloud on Google Cloud Platform. GCP is now the main point of entry to use Felis Cloud.</li> <li>Added a warning when instancing the <code>AliceBobRemoteProvider</code> if a new version of the provider is available on pypi.</li> </ul>"},{"location":"reference/changelog/#version-060","title":"Version 0.6.0","text":"<ul> <li>Improved feedback while running circuits using the remote provider</li> </ul>"},{"location":"reference/changelog/#version-054","title":"Version 0.5.4","text":"<ul> <li>Add support for the TDG gate for the logical backends of the remote provider (the TDG gate was already supported on the local provider)</li> </ul>"},{"location":"reference/changelog/#version-053","title":"Version 0.5.3","text":"<ul> <li>Fix a transpilation issue that prevented the usage of logical backends with the remote provider.</li> </ul>"},{"location":"reference/changelog/#version-052","title":"Version 0.5.2","text":"<ul> <li>Fix a transpilation issue for the logical backends, preventing the transpilation of circuits using a cswap gate.</li> </ul>"},{"location":"reference/changelog/#version-051","title":"Version 0.5.1","text":"<ul> <li>Improved transpilation and scheduling for the local backends, to better support programs imported from QASM code.</li> </ul>"},{"location":"reference/changelog/#version-050","title":"Version 0.5.0","text":"<ul> <li>Harmonized the <code>get_backend</code> functions of the remote and local provider to act in a similar manner. The following line is now working as it does for local:</li> </ul> <pre><code>remote_provider.get_backend('EMU:6Q:PHYSICAL_CATS', average_nb_photons=4.5, kappa_1=1000)\n</code></pre>"},{"location":"reference/changelog/#version-042","title":"Version 0.4.2","text":"<ul> <li>Released multi-qubits logical and physical targets for the remote provider, allowing to run these models remotely.</li> </ul>"},{"location":"reference/changelog/#version-041","title":"Version 0.4.1","text":"<ul> <li>Added support for Python 3.11</li> </ul>"},{"location":"reference/changelog/#version-040","title":"Version 0.4.0","text":"<ul> <li>Added logical backends: <code>EMU:15Q:LOGICAL_EARLY</code> and <code>EMU:40Q:LOGICAL_TARGET</code></li> </ul>"},{"location":"reference/error_models/","title":"About error models in emulators","text":"<p>Our emulators try to replicate as accurately as possible the behavior of past and current Alice &amp; Bob chips. They also try to forecast what the behavior of future Alice &amp; Bob chips might look like.</p> <p>Since these emulators are open sourced, you are free to explore the mathematical models we used, but we also want to explain how we came up with these models.</p> <p>This page, which we will update shortly, will give a detailed explanation for each of our backends.</p>"},{"location":"reference/error_models/#lescanne-2020","title":"Lescanne 2020","text":"<p>To be added</p>"},{"location":"reference/error_models/#physical-cats","title":"Physical cats","text":"<p>To be added</p>"},{"location":"reference/error_models/#logical-qubits","title":"Logical qubits","text":"<p>To be added</p>"},{"location":"reference/faq/","title":"Frequently asked questions","text":""},{"location":"reference/faq/#what-can-i-do-with-a-single-qubit","title":"What can I do with a single qubit?","text":"<p>You will of course not run useful algorithms, but you can benchmark the qubit's performance.</p> <p>For example, you may:</p> <ul> <li>Measure the qubit's bit-flip and phase-flip lifetime</li> <li>Measure SPAM (State Preparation And Measurement) fidelity</li> <li>Measure gate fidelities </li> </ul> <p>All these measurements can be made with different values of <code>average_nb_photons</code>, to verify that adding photons affects performance in the way predicted by theory (exponential improvement of bit-flip performance and linear decrease of phase-flip performance).</p> <p>See the following notebook for a few examples</p>"},{"location":"reference/faq/#measuring-long-bit-flip-lifetimes-takes-hours-how-can-i-make-this-shorter","title":"Measuring long bit-flip lifetimes takes hours. How can I make this shorter?","text":"<p>Currently, the only way to measure a bit-flip lifetime is to repeat a few thousand times some experiments whose duration is comparable to the lifetime we want to measure, as shown in this notebook for example.</p> <p>Although this is an acceptable method when the lifetime is measured in microseconds, this is no longer practical when the lifetime reaches several minutes with chips such as Boson 4. At high numbers of photons, getting a reliable measurement may take several hours, sometimes even a full day.</p> <p>We're working on introducing the \"real-time trajectories\" protocol featured in our recent Nature paper (arXiv link), which will greatly reduce the time needed to measure long bit-flip lifetimes.</p>"},{"location":"reference/faq/#boson-4s-phase-flip-performance-is-disappointing-is-there-any-chance-it-will-improve","title":"Boson 4's phase-flip performance is disappointing. Is there any chance it will improve?","text":"<p>There are two things to consider here:</p> <ul> <li>X readout fidelity</li> <li>Phase-flip lifetime</li> </ul> <p>The most visible issue is the X readout fidelity, which can be witnessed when measuring SPAM fidelity with a \"Prepare \\(\\ket{+}\\) - Measure \\(X\\)\" sequence. Our transmon-free X readout technique was introduced in our recent Nature paper (arXiv link), as a first of its kind. It enabled us to reach very long bit-flip lifetimes, but it still lacks optimization. We must however optimize it so it can be used in a phase-flip QEC scheme. This is why:</p> <ul> <li>We are currently developing new transmon-free readout techniques that will enable us to reach below threshold operation.</li> <li>We may open pulse-level access to a Boson 4 chip to accelerate the discovery of new techniques. Let us know if you are interested in a collaboration.</li> </ul> <p>Concerning the phase-flip lifetime:</p> <ul> <li>We are currently working on our nanofabrication to increase the resonators T1s.</li> <li>We are also implementing stronger stabilization techniques that will make our qubit gates faster and hence less error prone.</li> </ul> <p>All of this is work in progress and we are looking forward to sharing our progress by making new chips available on Felis Cloud.</p>"},{"location":"reference/faq/#why-are-felis-cloud-jobs-limited-to-15-minutes","title":"Why are Felis Cloud jobs limited to 15 minutes?","text":"<p>Since there is only one Boson 4 chip available, limiting job duration ensures that the chip will not be blocked by a single user for a long period of time.</p> <p>If you need exclusive access to the chip for a long period of time, please contact us.</p>"},{"location":"reference/faq/#why-do-physical-backends-not-support-hadamard-gates","title":"Why do physical backends not support Hadamard gates?","text":"<p>A very important property of cat qubits is their biased noise: their bit-flip lifetime is much longer than their phase-flip lifetime. This property makes it possible to use much simpler quantum error correction codes.</p> <p>But the Hadamard gate breaks this property: because it transforms the \\(\\ket{+}\\) state into the \\(\\ket{0}\\) state, it transforms a phase-flip into a bit-flip, therefore shortening the bit-flip lifetime. We say that the Hadamard gate is not \"bias-preserving\".</p> <p>While it would be technically possible to implement a Hadamard gate on physical cat qubits, we choose not to do it and we implement error correction using only bias-preserving gates. We then apply Hadamard gates on error-corrected logical qubits.</p> <p>But on a physical backend, even without a Hadamard gate, you may: </p> <ul> <li>Initialize a qubit in the \\(\\ket{+}\\) state using <code>initialize('+', qubit_index)</code></li> <li>Perform a X measurement using <code>measure_x(qubit_index, clbit_index)</code></li> </ul>"},{"location":"reference/faq/#when-will-a-multi-qubit-chip-be-available-in-felis-cloud","title":"When will a multi-qubit chip be available in Felis Cloud?","text":"<p>Probably not before 2025. But we are already working on it and will keep you updated. In the mean time, we will release updates to Boson 4 to broaden the range of experiments which can be performed with it.</p>"},{"location":"reference/faq/#when-will-pulse-level-access-be-available","title":"When will pulse-level access be available?","text":"<p>We are looking into this. If you have experiments in mind, please contact us!.</p>"},{"location":"reference/papers/","title":"Useful scientific papers","text":""},{"location":"reference/papers/#exponential-suppression-of-bit-flips-in-a-qubit-encoded-in-an-oscillator","title":"Exponential suppression of bit-flips in a qubit encoded in an oscillator","text":"<p>The first paper you'll want to read about cat qubits is the seminal paper by our CTO and co-founder Rapha\u00ebl Lescanne. It explains the physics of cat qubits and shows a first experimental realization, which led to the foundation of Alice &amp; Bob.</p> <p>The chip in this paper is now called \"Boson 1\".</p> <ul> <li>Nature: https://www.nature.com/articles/s41567-020-0824-x</li> <li>arXiv: https://arxiv.org/abs/1907.11729</li> </ul>"},{"location":"reference/papers/#repetition-cat-qubits-for-fault-tolerant-quantum-computation","title":"Repetition Cat Qubits for Fault-Tolerant Quantum Computation","text":"<p>Cat qubits are interesting because they make it easy to implement error correction. In this paper by our Chief of Theory J\u00e9r\u00e9mie Guillaud, you'll learn how to implement a repetition code using cat qubits.</p> <ul> <li>Physical Review X: https://journals.aps.org/prx/abstract/10.1103/PhysRevX.9.041053</li> </ul>"},{"location":"reference/papers/#one-hundred-second-bit-flip-time-in-a-two-photon-dissipative-oscillator","title":"One hundred second bit-flip time in a two-photon dissipative oscillator","text":"<p>While the bit-flip lifetime of the chip in Rapha\u00ebl Lescanne's seminal experiment was limited to 1 ms, we found ways to extend this figure by several orders of magnitude. In this paper by Camille Berdou et al., we show how we can take the bit-flip lifetime to over 10\" by removing the transmon used for measuring the cat qubit's state.</p> <p>The chip in this paper is now called \"Boson 2\".</p> <ul> <li>Physical Review X Quantum: https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.4.020350</li> </ul>"},{"location":"reference/papers/#quantum-control-of-a-cat-qubit-with-bit-flip-times-exceeding-ten-seconds","title":"Quantum control of a cat-qubit with bit-flip times exceeding ten seconds","text":"<p>\"Boson 2\" showed very promising bit-flip lifetimes, but it lacked a protocol to measure phase-flips. This paper by Ulysse R\u00e9glade et al. introduces a new measurement protocol and a new chip, making it possible to witness macroscopic bit-flip lifetimes (over 10 seconds) while retaining the ability to measure phase-flips.</p> <p>The chip in this paper is now called \"Boson 3\".</p> <ul> <li>Nature: https://www.nature.com/articles/s41586-024-07294-3</li> <li>arXiv: https://arxiv.org/abs/2307.06617</li> </ul>"},{"location":"reference/papers/#autoparametric-resonance-extending-the-bit-flip-time-of-a-cat-qubit-up-to-03-s","title":"Autoparametric Resonance Extending the Bit-Flip Time of a Cat Qubit up to 0.3 s","text":"<p>In parallel, we also explore better transmon-based designs, such as AutoCat which reached a 0.3 s bit-flip lifetime and a better phase-flip performance (error rate as low as 3.5 % for the Z gate).</p> <ul> <li>Physical Review X: https://journals.aps.org/prx/abstract/10.1103/PhysRevX.14.021019</li> </ul>"},{"location":"reference/papers/#performance-analysis-of-a-repetition-cat-code-architecture-computing-256-bit-elliptic-curve-logarithm-in-9-hours-with-126133-cat-qubits","title":"Performance Analysis of a Repetition Cat Code Architecture: Computing 256-bit Elliptic Curve Logarithm in 9 Hours with 126133 Cat Qubits","text":"<p>The reason why we invest in cat qubits is that they make it possible to reach the very low error rates required to run quantum computing's landmark algorithms. In this paper by \u00c9lie Gouzien et al., we describe the architecture of a fault-tolerant computer which can run Shor's algorithm using 60x fewer qubits than an architecture using transmons and a surface code.</p> <ul> <li>Physical Review Letters: https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.131.040602</li> <li>arXiv: https://arxiv.org/abs/2302.06639</li> </ul>"},{"location":"reference/papers/#ldpc-cat-codes-for-low-overhead-quantum-computing-in-2d","title":"LDPC-cat codes for low-overhead quantum computing in 2D","text":"<p>And finally, our latest theoretical breakthrough is the adaptation of LDPC codes to cat qubits, which further reduces the number of qubits needed to run useful algorithms. In this paper by Diego Ruiz et al., written in collaboration with Inria, we show how to implement 100 logical qubits with only 1,500 physical qubits, or run Shor's algorithm with 200x fewer qubits than transmons with a surface code.</p> <ul> <li>Nature: https://www.nature.com/articles/s41467-025-56298-8</li> </ul>"},{"location":"reference/supported_instructions/","title":"Supported instructions","text":""},{"location":"reference/supported_instructions/#supported-qiskit-gates","title":"Supported Qiskit gates","text":""},{"location":"reference/supported_instructions/#custom-felis-gates","title":"Custom Felis gates","text":"<p>All Felis backends support two custom gates: <code>initialize</code> and <code>measure_x</code>:</p> <ul> <li> <p><code>initialize(value, qubit_index)</code></p> <ul> <li>It initializes qubit <code>qubit_index</code> to one of four supported <code>value</code>:   <code>'0'</code>, <code>'1'</code>, <code>'+'</code>, <code>'-'</code></li> </ul> </li> <li> <p><code>measure_x(qubit_index, clbit_index)</code></p> <ul> <li>It performs an X measurement on qubit <code>qubit_index</code> and stores the result in the classical bit <code>clbit_index</code></li> </ul> </li> </ul> <p>While these gates can be theoretically recreated using <code>X</code>, <code>H</code> and <code>Z</code> gates, they are still needed because:</p> <ul> <li>In physical backends, <code>H</code> is not supported</li> <li>In logical backends, they are a less costly way to initialize and measure than by using several gates</li> </ul> <p>In addition to these two gates, you may use some or all of the other gates listed in the Qiskit documentation.</p> <p>The sections below list which gates you may use depending on the backend you're using.</p>"},{"location":"reference/supported_instructions/#logical-backends","title":"Logical backends","text":"<p>We have two candidate logical gate sets for our future error-corrected quantum processors:</p> <ul> <li>Hadamard + Toffoli</li> <li>Clifford + T</li> </ul> <p>Depending on the use case, one may yield better results than the other. In the scope of Felis' logical backends, we chose to support both T and Toffoli gates, so you can choose to which gate set you will transpile your programs. Our engine currently only transpiles to Clifford + T.</p> <p>More precisely, the gates natively supported by all logical backends are:</p> <ul> <li><code>initialize</code> (custom Felis gate)</li> <li><code>measure_x</code> (custom Felis gate)</li> <li><code>delay</code> (native Qiskit gate)</li> <li><code>x</code> (native Qiskit gate)</li> <li><code>z</code> (native Qiskit gate)</li> <li><code>measure</code> (native Qiskit gate)</li> <li><code>t</code> (native Qiskit gate)</li> <li><code>tdg</code> (native Qiskit gate)</li> <li><code>h</code> (native Qiskit gate)</li> <li><code>s</code> (native Qiskit gate)</li> <li><code>sdg</code> (native Qiskit gate)</li> <li><code>cx</code> (native Qiskit gate)</li> <li><code>ccx</code> (native Qiskit gate)</li> </ul> <p>If the gate is not part of this native gate set, it will be implemented through transpilation, as shown in this example.</p>"},{"location":"reference/supported_instructions/#physical-backends","title":"Physical backends","text":"<p>Physical backends support a limited set of gates, summarized in this table:</p> Instruction [QPU:1Q:BOSON_4x] [EMU:1Q:LESCANNE_2020] [EMU:6/40Q:PHYSICAL_CATS] <code>delay</code> \u2705 \u2705 \u2705 <code>initialize</code> \u2705 \u2705 \u2705 <code>z</code> \u2705 \u2705 \u2705 <code>x</code> \u2705 \u274c \u2705 <code>rz</code> \u274c \u2705 \u2705 <code>cx</code> \u274c \u274c \u2705 <code>measure</code> \u2705 \u2705 \u2705 <code>measure_x</code> \u2705 \u2705 \u2705 <p>Note that these operations are all bias-preserving (i.e. they do not convert a phase-flip error into a bit-flip error).</p> <p>Because this gate set is not universal, transpiling an arbitrary circuit for physical backends is usually not possible. Physical backends are meant to run error correction experiments, rather than algorithms. If you want to run algorithms, consider using logical backends instead.</p> <p>To know which gate is supported by which backend, check the table above or your backend's page in the Backends section</p>"},{"location":"reference/supported_instructions/#supported-qir-instructions","title":"Supported QIR instructions","text":"<p>The API exposes the list of available targets (the equivalent of Qiskit backends) and details for each of them the list of supported instructions.</p> <p>https://api-gcp.alice-bob.com/v1/targets/</p> <ul> <li> <p>Here\u2019s a sample response (for the <code>EMU:1Q:LESCANNE_2020</code> model only).</p> <p><code>json [     {         \"name\": \"EMU:1Q:LESCANNE_2020\",         \"numQubits\": 1,         \"instructions\": [             {                 \"signature\": \"__quantum__qis__read_result__body:i1 (%Result*)\"             },             {                 \"signature\": \"__quantum__qis__z__body:void (%Qubit*)\"             },             {                 \"signature\": \"__quantum__qis__x__body:void (%Qubit*)\"             },             {                 \"signature\": \"__quantum__qis__mz__body:void (%Qubit*, %Result*)\"             },             {                 \"signature\": \"__quantum__qis__m__body:void (%Qubit*, %Result*)\"             },             {                 \"signature\": \"__quantum__qis__measure__body:void (%Qubit*, %Result*)\"             },             {                 \"signature\": \"__quantum__qis__mx__body:void (%Qubit*, %Result*)\"             },             {                 \"signature\": \"__quantum__qis__reset__body:void (%Qubit*)\"             },             {                 \"signature\": \"__quantum__qis__delay__body:void (double, %Qubit*)\"             },             {                 \"signature\": \"__quantum__qis__prepare_x__body:void (i1, %Qubit*)\"             },             {                 \"signature\": \"__quantum__qis__prepare_z__body:void (i1, %Qubit*)\"             },             {                 \"signature\": \"__quantum__qis__rz__body:void (double, %Qubit*)\"             }         ],         \"inputParams\": {             \"nbShots\": {                 \"required\": true,                 \"default\": 1000,                 \"constraints\": [                     {                         \"min\": 1,                         \"max\": 10000000                     }                 ]             },             \"averageNbPhotons\": {                 \"required\": true,                 \"default\": 4.0,                 \"constraints\": [                     {                         \"min\": 1.0,                         \"max\": 7.0                     }                 ]             }         }     },   ... ]</code></p> </li> </ul> <p>When working with the remote provider <code>AliceBobRemoteProvider</code>, the supported QIR instructions are fetched by the provider from the API and converted into Qiskit instructions.</p>"},{"location":"reference/the_api/","title":"The API","text":"<p>If you want to integrate Felis with other tools, you may need to interact directly with our API.</p> <p>It can be accessed at https://api-gcp.alice-bob.com/v1/.</p> <p>Here\u2019s an example listing all jobs, pending or completed:</p> <pre><code>curl --request GET \\\n  --url https://api-gcp.alice-bob.com//v1/jobs/ \\\n  --header 'Authorization: Basic &lt;API key&gt;'\n</code></pre> <p>Note the use of an API key: this is the same API key as the one used with the Qiskit provider <code>AliceBobRemoteProvider(api_key=&lt;API key&gt;)</code>. That\u2019s because the Qiskit provider interacts with the API.</p> <p>Use the same API key with the API as with the Qiskit provider <code>AliceBobRemoteProvider</code>. That\u2019s because the provider itself is backed by the API. For more information, see Install the Qiskit provider.</p> <p>The up-to-date API reference can be accessed here: </p> <p>Alice &amp; Bob - Cloud API - ReDoc</p>"}]}